var documenterSearchIndex = {"docs":
[{"location":"tutorial/5_benchmark/#Benchmark","page":"Benchmark","title":"Benchmark","text":"Here we compare the performance of MetaGraphsNext.jl with its predecessor MetaGraphs.jl.\n\nusing BenchmarkTools\nusing Graphs\nusing InteractiveUtils\nusing MetaGraphs: MetaGraphs\nusing MetaGraphsNext: MetaGraphsNext\n\nThe benchmarking task is two-fold:\n\nBuild a complete graph with random boolean metadata on the vertices (active) and float metadata on the edges (distance)\nCompute the sum of distances for all edges whose endpoints are both active.","category":"section"},{"location":"tutorial/5_benchmark/#Graph-construction","page":"Benchmark","title":"Graph construction","text":"function build_incremental_metagraphsnext(n)\n    g = Graph(0)\n    mg = MetaGraphsNext.MetaGraph(\n        g;\n        label_type=Int,  # this will throw a warning\n        vertex_data_type=Bool,\n        edge_data_type=Float64,\n    )\n    for li in 1:n\n        mg[li] = rand(Bool)\n    end\n    for li in 1:n, lj in 1:(li - 1)\n        mg[li, lj] = rand(Float64)\n    end\n    return mg\nend;\nnothing #hide\n\nfunction build_bulk_metagraphsnext(n)\n    g = complete_graph(n)\n    vertices_description = [li => rand(Bool) for li in 1:n]\n    edges_description = [(li, lj) => rand(Float64) for li in 1:n for lj in 1:(li - 1)]\n    mg = MetaGraphsNext.MetaGraph(g, vertices_description, edges_description;)\n    return mg\nend;\nnothing #hide\n\nfunction build_metagraphs(n)\n    g = complete_graph(n)\n    mg = MetaGraphs.MetaGraph(g)\n    for i in 1:n\n        MetaGraphs.set_prop!(mg, i, :active, rand(Bool))\n    end\n    for i in 1:n, j in 1:(i - 1)\n        MetaGraphs.set_prop!(mg, i, j, :distance, rand(Float64))\n    end\n    return mg\nend;\nnothing #hide\n\n@btime build_incremental_metagraphsnext(100);\nnothing #hide\n\n@btime build_bulk_metagraphsnext(100);\nnothing #hide\n\n@btime build_metagraphs(100);\nnothing #hide","category":"section"},{"location":"tutorial/5_benchmark/#Graph-exploitation","page":"Benchmark","title":"Graph exploitation","text":"function sum_active_edges_metagraphsnext(mg)\n    S = 0.0\n    for (li, lj) in MetaGraphsNext.edge_labels(mg)\n        active_i = mg[li]\n        active_j = mg[lj]\n        distance_ij = mg[li, lj]\n        if active_i && active_j\n            S += distance_ij\n        end\n    end\n    return S\nend\n\nfunction sum_active_edges_metagraphs(mg)\n    S = 0.0\n    for e in edges(mg)\n        i, j = src(e), dst(e)\n        active_i = MetaGraphs.get_prop(mg, i, :active)\n        active_j = MetaGraphs.get_prop(mg, j, :active)\n        distance_ij = MetaGraphs.get_prop(mg, i, j, :distance)\n        if active_i && active_j\n            S += distance_ij\n        end\n    end\n    return S\nend\n\nmg1 = build_incremental_metagraphsnext(100);\n@btime sum_active_edges_metagraphsnext($mg1);\nnothing #hide\n\nmg2 = build_metagraphs(100);\n@btime sum_active_edges_metagraphs($mg2);\nnothing #hide\n\nThe difference in performance can be explained by type instability.\n\n@code_warntype sum_active_edges_metagraphsnext(mg1);\nnothing #hide\n\n@code_warntype sum_active_edges_metagraphs(mg2);\nnothing #hide\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"tutorial/1_basics/#Basics","page":"Basics","title":"Basics","text":"using Graphs\nusing MetaGraphsNext","category":"section"},{"location":"tutorial/1_basics/#Creating-an-empty-MetaGraph","page":"Basics","title":"Creating an empty MetaGraph","text":"We provide a convenience constructor for creating empty graphs, which looks as follows:\n\ncolors = MetaGraph(\n    Graph();  # underlying graph structure\n    label_type=Symbol,  # color name\n    vertex_data_type=NTuple{3,Int},  # RGB code\n    edge_data_type=Symbol,  # result of the addition between two colors\n    graph_data=\"additive colors\",  # tag for the whole graph\n)\n\nThe label_type argument defines how vertices will be referred to. It can be anything you want, provided that pairs of labels can be compared with <. Integer types are generally discouraged, to avoid confusion with the vertex codes used by Graphs.jl. The vertex_data_type and edge_data_type type determine what kind of data will be associated with each vertex and edge. Finally, graph_data can contain an arbitrary object associated with the graph as a whole.\n\nIf you don't care about labels at all, using the integer vertex codes as labels may be reasonable. Just keep in mind that labels do not change with vertex deletion, whereas vertex codes get decreased, so the coherence will be broken.","category":"section"},{"location":"tutorial/1_basics/#Modifying-the-graph","page":"Basics","title":"Modifying the graph","text":"Modifications of graph elements and the associated metadata can always be done using setindex! (as in a dictionary) with the relevant labels.","category":"section"},{"location":"tutorial/1_basics/#Vertices","page":"Basics","title":"Vertices","text":"Use setindex! with one key to add a new vertex with the given label and metadata. If a vertex with the given label does not exist, it will be created automatically. Otherwise, the function will simply modify the metadata for the existing vertex.\n\ncolors[:red] = (255, 0, 0);\ncolors[:green] = (0, 255, 0);\ncolors[:blue] = (0, 0, 255);\nnothing #hide\n\nNote that you cannot use labels or metadata that is incoherent with the types you specified at construction.","category":"section"},{"location":"tutorial/1_basics/#Edges","page":"Basics","title":"Edges","text":"Use setindex! with two keys to add a new edge between the given labels and containing the given metadata. Beware that this time, an edge will only be added when both node labels already exist in the graph.\n\ncolors[:red, :green] = :yellow;\ncolors[:red, :blue] = :magenta;\ncolors[:green, :blue] = :cyan;\nnothing #hide","category":"section"},{"location":"tutorial/1_basics/#Creating-a-non-empty-MetaGraph","page":"Basics","title":"Creating a non-empty MetaGraph","text":"There is an alternative constructor which allows you to build and fill the graph in one fell swoop. Here's how it works:\n\ngraph = Graph(Edge.([(1, 2), (1, 3), (2, 3)]))\nvertices_description = [:red => (255, 0, 0), :green => (0, 255, 0), :blue => (0, 0, 255)]\nedges_description = [\n    (:red, :green) => :yellow, (:red, :blue) => :magenta, (:green, :blue) => :cyan\n]\n\ncolors2 = MetaGraph(graph, vertices_description, edges_description, \"additive colors\")\ncolors2 == colors","category":"section"},{"location":"tutorial/1_basics/#Accessing-graph-properties","page":"Basics","title":"Accessing graph properties","text":"To retrieve graph properties, we still follow a dictionary-like interface based on labels.","category":"section"},{"location":"tutorial/1_basics/#Existence","page":"Basics","title":"Existence","text":"To check the presence of a vertex or edge, use haskey:\n\nhaskey(colors, :red)\n\nhaskey(colors, :black)\n\nhaskey(colors, :red, :green) && haskey(colors, :green, :red)\n\n!haskey(colors, :red, :black)","category":"section"},{"location":"tutorial/1_basics/#Metadata","page":"Basics","title":"Metadata","text":"All kinds of metadata can be accessed with getindex:\n\ncolors[]\n\ncolors[:blue]\n\ncolors[:green, :blue]","category":"section"},{"location":"tutorial/1_basics/#Using-vertex-codes","page":"Basics","title":"Using vertex codes","text":"In the absence of removal, vertex codes correspond to order of insertion in the underlying graph. They are the ones used by most algorithms in the Graphs.jl ecosystem.\n\ncode_for(colors, :red)\n\ncode_for(colors, :blue)\n\nYou can retrieve the associated labels as follows:\n\nlabel_for(colors, 1)\n\nlabel_for(colors, 3)","category":"section"},{"location":"tutorial/1_basics/#Listing-labels","page":"Basics","title":"Listing labels","text":"The functions labels, edge_labels, (in/out)neighbor_labels iterate through labels the same way that vertices, edges and (in/out)neighbors iterate through codes.\n\ncollect(labels(colors))\n\ncollect(edge_labels(colors))\n\ncollect(neighbor_labels(colors, :red))","category":"section"},{"location":"tutorial/1_basics/#Handling-weights","page":"Basics","title":"Handling weights","text":"You can use the weight_function field to specify a function which will transform edge metadata into a weight. This weight must always have the same type as the default_weight, which is the value returned in case an edge does not exist.\n\nweighted = MetaGraph(\n    Graph();\n    label_type=Symbol,\n    edge_data_type=Float64,\n    weight_function=ed -> ed^2,\n    default_weight=Inf,\n);\n\nweighted[:alice] = nothing;\nweighted[:bob] = nothing;\nweighted[:charlie] = nothing;\n\nweighted[:alice, :bob] = 2.0;\nweighted[:bob, :charlie] = 3.0;\nnothing #hide\n\nweight_matrix = Graphs.weights(weighted)\n\ndefault_weight(weighted)\n\nsize(weight_matrix)\n\nweight_matrix[1, 2]\n\nweight_matrix[2, 3]\n\nweight_matrix[1, 3]\n\nwf = get_weight_function(weighted)\nwf(4.0)\n\nYou can then use all functions from Graphs.jl that require weighted graphs (see the rest of the tutorial).\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"api/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api/#Docstrings","page":"API reference","title":"Docstrings","text":"","category":"section"},{"location":"api/#Index","page":"API reference","title":"Index","text":"","category":"section"},{"location":"api/#MetaGraphsNext.MetaGraphsNext","page":"API reference","title":"MetaGraphsNext.MetaGraphsNext","text":"MetaGraphsNext\n\nA package for graphs with vertex labels and metadata in Julia. Its main export is the MetaGraph type.\n\n\n\n\n\n","category":"module"},{"location":"api/#MetaGraphsNext.DOTFormat","page":"API reference","title":"MetaGraphsNext.DOTFormat","text":"struct DOTFormat <: AbstractGraphFormat end\n\nIf all metadata types support pairs or are Nothing, you can save MetaGraphs in DOTFormat.\n\n\n\n\n\n","category":"type"},{"location":"api/#MetaGraphsNext.MGFormat","page":"API reference","title":"MetaGraphsNext.MGFormat","text":"struct MGFormat <: AbstractGraphFormat end\n\nYou can save MetaGraphs in a MGFormat, currently based on JLD2.\n\n\n\n\n\n","category":"type"},{"location":"api/#MetaGraphsNext.MetaGraph","page":"API reference","title":"MetaGraphsNext.MetaGraph","text":"MetaGraph{\n    Code<:Integer,\n    Graph<:AbstractGraph{Code},\n    Label,\n    VertexData,\n    EdgeData,\n    GraphData,\n    WeightFunction,\n    Weight\n} <: AbstractGraph{Code}\n\nA graph type with custom vertex labels containing vertex-, edge- and graph-level metadata.\n\nVertex labels have type Label, while vertex (resp. edge, resp. graph) metadata has type VertexData (resp. EdgeData, resp. GraphData). It is recommended not to set Label to an integer type, so as to avoid confusion between vertex labels (which do not change as the graph evolves) and vertex codes (which have type Code<:Integer and can change as the graph evolves).\n\nFields\n\ngraph::Graph: underlying, data-less graph with vertex codes of type Code\nvertex_labels::Dict{Code,Label}: dictionary mapping vertex codes to vertex labels\nvertex_properties::Dict{Label,Tuple{Code,VertexData}}: dictionary mapping vertex labels to vertex codes & metadata\nedge_data::Dict{Tuple{Label,Label},EdgeData}: dictionary mapping edge labels such as (label_u, label_v) to edge metadata\ngraph_data::GraphData: metadata for the graph object as a whole\nweight_function::WeightFunction: function computing edge weight from edge metadata, its output must have the same type as default_weight\ndefault_weight::Weight: default weight used when an edge doesn't exist\n\n\n\n\n\n","category":"type"},{"location":"api/#MetaGraphsNext.MetaGraph-Tuple{Any}","page":"API reference","title":"MetaGraphsNext.MetaGraph","text":"MetaGraph(\n    graph;\n    label_type,\n    vertex_data_type=Nothing,\n    edge_data_type=Nothing,\n    graph_data=nothing,\n    weight_function=edge_data -> 1.0,\n    default_weight=1.0\n)\n\nConstruct an empty MetaGraph based on an empty graph, initializing storage with metadata types given as keyword arguments.\n\nwarning: Warning\nThis constructor uses keyword arguments for convenience, which means it is type-unstable.\n\n\n\n\n\n","category":"method"},{"location":"api/#MetaGraphsNext.MetaGraph-Union{Tuple{EdgeData}, Tuple{VertexData}, Tuple{Label}, Tuple{Code}, Tuple{AbstractGraph{Code}, Array{Pair{Label, VertexData}, 1}, Array{Pair{Tuple{Label, Label}, EdgeData}, 1}}, Tuple{AbstractGraph{Code}, Array{Pair{Label, VertexData}, 1}, Array{Pair{Tuple{Label, Label}, EdgeData}, 1}, Any}, Tuple{AbstractGraph{Code}, Array{Pair{Label, VertexData}, 1}, Array{Pair{Tuple{Label, Label}, EdgeData}, 1}, Any, Any}, Tuple{AbstractGraph{Code}, Array{Pair{Label, VertexData}, 1}, Array{Pair{Tuple{Label, Label}, EdgeData}, 1}, Any, Any, Any}} where {Code, Label, VertexData, EdgeData}","page":"API reference","title":"MetaGraphsNext.MetaGraph","text":"MetaGraph(\n    graph,\n    vertices_description,\n    edges_description,\n    graph_data=nothing,\n    weight_function=edge_data -> 1.0,\n    default_weight=1.0,\n)\n\nConstruct a non-empty MetaGraph based on a non-empty graph with specified vertex and edge data, given as positional arguments.\n\nThe data must be given as follows:\n\nvertices_description is a vector of pairs label => data (the code of a vertex will correspond to its rank in the list)\nedges_description is a vector of pairs (label1, label2) => data\n\nFurthermore, these arguments must be coherent with the graph argument, i.e. describe the same set of vertices and edges.\n\n\n\n\n\n","category":"method"},{"location":"api/#MetaGraphsNext.MetaGraph-Union{Tuple{EdgeData}, Tuple{VertexData}, Tuple{Label}, Tuple{Code}, Tuple{AbstractGraph{Code}, Type{Label}}, Tuple{AbstractGraph{Code}, Type{Label}, Type{VertexData}}, Tuple{AbstractGraph{Code}, Type{Label}, Type{VertexData}, Type{EdgeData}}, Tuple{AbstractGraph{Code}, Type{Label}, Type{VertexData}, Type{EdgeData}, Any}, Tuple{AbstractGraph{Code}, Type{Label}, Type{VertexData}, Type{EdgeData}, Any, Any}, Tuple{AbstractGraph{Code}, Type{Label}, Type{VertexData}, Type{EdgeData}, Any, Any, Any}} where {Code, Label, VertexData, EdgeData}","page":"API reference","title":"MetaGraphsNext.MetaGraph","text":"MetaGraph(\n    graph,\n    label_type,\n    vertex_data_type=Nothing,\n    edge_data_type=Nothing,\n    graph_data=nothing,\n    weight_function=edge_data -> 1.0,\n    default_weight=1.0\n)\n\nConstruct an empty MetaGraph based on an empty graph, initializing storage with metadata types given as positional arguments.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.delete!-Tuple{MetaGraph, Any, Any}","page":"API reference","title":"Base.delete!","text":"delete!(meta_graph, label_1, label_2)\n\nDelete edge (label_1, label_2).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.delete!-Tuple{MetaGraph, Any}","page":"API reference","title":"Base.delete!","text":"delete!(meta_graph, label)\n\nDelete vertex label.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{MetaGraph, Any, Any}","page":"API reference","title":"Base.getindex","text":"getindex(meta_graph, label_1, label_2)\n\nReturn edge metadata for the edge between label_1 and label_2.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{MetaGraph, Any}","page":"API reference","title":"Base.getindex","text":"getindex(meta_graph, label)\n\nReturn vertex metadata for label.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{MetaGraphsNext.MetaWeights, Integer, Integer}","page":"API reference","title":"Base.getindex","text":"getindex(meta_weights::MetaWeights, code_1, code_2)\n\nGet the weight of edge (code_1, code_2).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{MetaGraph}","page":"API reference","title":"Base.getindex","text":"getindex(meta_graph)\n\nReturn meta_graph metadata.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.haskey-Tuple{MetaGraph, Any, Any}","page":"API reference","title":"Base.haskey","text":"haskey(meta_graph, label_1, label_2)\n\nDetermine whether a MetaGraph meta_graph contains an edge from label_1 to label_2.\n\nThe order of label_1 and label_2 only matters if meta_graph is a digraph.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.haskey-Tuple{MetaGraph, Any}","page":"API reference","title":"Base.haskey","text":"haskey(meta_graph, label)\n\nDetermine whether a MetaGraph meta_graph contains the vertex label.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.setindex!-Tuple{MetaGraph, Any, Any, Any}","page":"API reference","title":"Base.setindex!","text":"setindex!(meta_graph, data, label_1, label_2)\n\nSet edge metadata for (label_1, label_2) to data.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.setindex!-Tuple{MetaGraph, Any, Any}","page":"API reference","title":"Base.setindex!","text":"setindex!(meta_graph, data, label)\n\nSet vertex metadata for label to data.\n\n\n\n\n\n","category":"method"},{"location":"api/#Graphs.SimpleGraphs.add_edge!-Tuple{MetaGraph, Any, Any, Any}","page":"API reference","title":"Graphs.SimpleGraphs.add_edge!","text":"add_edge!(meta_graph, label_1, label_2, data)\n\nAdd an edge (label_1, label_2) to MetaGraph meta_graph with metadata data. If the EdgeData type of meta_graph is Nothing, data can be omitted.\n\nReturn true if the edge has been added, false otherwise. If one of the labels does not exist, nothing happens and false is returned (the label is not inserted). If (label_1, label_2) already exists, its data is updated to data and false is returned nonetheless.\n\n\n\n\n\n","category":"method"},{"location":"api/#Graphs.SimpleGraphs.add_vertex!-Tuple{MetaGraph, Any, Any}","page":"API reference","title":"Graphs.SimpleGraphs.add_vertex!","text":"add_vertex!(meta_graph, label, data)\n\nAdd a vertex to MetaGraph meta_graph with label label having metadata data. If the VertexData type of meta_graph is Nothing, data can be omitted.\n\nReturn true if the vertex has been added, false in case the label already exists or vertex was not added.\n\n\n\n\n\n","category":"method"},{"location":"api/#Graphs.weights-Tuple{MetaGraph}","page":"API reference","title":"Graphs.weights","text":"weights(meta_graph)\n\nReturn a matrix-like MetaWeights object containing the edge weights for metagraph meta_graph.\n\n\n\n\n\n","category":"method"},{"location":"api/#MetaGraphsNext._copy_props!-Tuple{MetaGraph, MetaGraph, Any}","page":"API reference","title":"MetaGraphsNext._copy_props!","text":"_copy_props!(old_meta_graph, new_meta_graph, code_map)\n\nCopy properties from old_meta_graph to new_meta_graph following vertex map code_map.\n\n\n\n\n\n","category":"method"},{"location":"api/#MetaGraphsNext.all_neighbor_labels-Tuple{MetaGraph, Any}","page":"API reference","title":"MetaGraphsNext.all_neighbor_labels","text":"all_neighbor_labels(meta_graph, label)\n\nIterate through all labels of all neighbors of the vertex code with label label, in the same order as the codes obtained by all_neighbors(meta_graph, code).\n\n\n\n\n\n","category":"method"},{"location":"api/#MetaGraphsNext.arrange","page":"API reference","title":"MetaGraphsNext.arrange","text":"arrange(graph, label_1, label_2)\n\nSort two vertex labels in a default order (useful to uniquely express undirected edges). For undirected graphs, the default order is based on the labels themselves to be robust to vertex re-coding, so the labels need to support <.\n\n\n\n\n\n","category":"function"},{"location":"api/#MetaGraphsNext.code_for-Tuple{MetaGraph, Any}","page":"API reference","title":"MetaGraphsNext.code_for","text":"code_for(meta_graph::MetaGraph, label)\n\nFind the vertex code (or index) associated with label label.\n\nThis can be useful to pass to methods inherited from Graphs. Note, however, that vertex codes can be reassigned after vertex deletion.\n\n\n\n\n\n","category":"method"},{"location":"api/#MetaGraphsNext.default_weight-Tuple{MetaGraph}","page":"API reference","title":"MetaGraphsNext.default_weight","text":"default_weight(meta_graph)\n\nReturn the default weight for metagraph meta_graph.\n\n\n\n\n\n","category":"method"},{"location":"api/#MetaGraphsNext.edge_labels-Tuple{MetaGraph}","page":"API reference","title":"MetaGraphsNext.edge_labels","text":"edge_labels(meta_graph)\n\nIterate through all tuples of edge labels, in the same order as the tuples of codes obtained by edges(meta_graph).\n\n\n\n\n\n","category":"method"},{"location":"api/#MetaGraphsNext.get_weight_function-Tuple{MetaGraph}","page":"API reference","title":"MetaGraphsNext.get_weight_function","text":"get_weight_function(meta_graph)\n\nReturn the weight function for metagraph meta_graph.\n\n\n\n\n\n","category":"method"},{"location":"api/#MetaGraphsNext.inneighbor_labels-Tuple{MetaGraph, Any}","page":"API reference","title":"MetaGraphsNext.inneighbor_labels","text":"inneighbor_labels(meta_graph, label)\n\nIterate through all labels of inneighbors of the vertex code with label label, in the same order as the codes obtained by inneighbors(meta_graph, code).\n\n\n\n\n\n","category":"method"},{"location":"api/#MetaGraphsNext.label_for-Tuple{MetaGraph, Integer}","page":"API reference","title":"MetaGraphsNext.label_for","text":"label_for(meta_graph::MetaGraph, code)\n\nFind the label associated with code code.\n\nThis can be useful to interpret the results of methods inherited from Graphs. Note, however, that vertex codes can be reassigned after vertex deletion.\n\n\n\n\n\n","category":"method"},{"location":"api/#MetaGraphsNext.labels-Tuple{MetaGraph}","page":"API reference","title":"MetaGraphsNext.labels","text":"labels(meta_graph)\n\nIterate through all vertex labels, in the same order as the codes obtained by vertices(meta_graph).\n\n\n\n\n\n","category":"method"},{"location":"api/#MetaGraphsNext.neighbor_labels-Tuple{MetaGraph, Any}","page":"API reference","title":"MetaGraphsNext.neighbor_labels","text":"neighbor_labels(meta_graph, label)\n\nIterate through all labels of neighbors of the vertex code with label label, in the same order as the codes obtained by neighbors(meta_graph, code).\n\n\n\n\n\n","category":"method"},{"location":"api/#MetaGraphsNext.outneighbor_labels-Tuple{MetaGraph, Any}","page":"API reference","title":"MetaGraphsNext.outneighbor_labels","text":"outneighbor_labels(meta_graph, label)\n\nIterate through all labels of outneighbors of the vertex code with label label, in the same order as the codes obtained by outneighbors(meta_graph, code).\n\n\n\n\n\n","category":"method"},{"location":"api/#MetaGraphsNext.set_data!-Tuple{MetaGraph, Any, Any, Any}","page":"API reference","title":"MetaGraphsNext.set_data!","text":"set_data!(meta_graph, label_1, label_2, data)\n\nSet edge metadata for (label_1, label_2) to data.\n\nReturn true if the operation succeeds, and false if meta_graph has no such edge.\n\n\n\n\n\n","category":"method"},{"location":"api/#MetaGraphsNext.set_data!-Tuple{MetaGraph, Any, Any}","page":"API reference","title":"MetaGraphsNext.set_data!","text":"set_data!(meta_graph, label, data)\n\nSet vertex metadata for label to data.\n\nReturn true if the operation succeeds, and false if meta_graph has no such vertex.\n\n\n\n\n\n","category":"method"},{"location":"api/#MetaGraphsNext.weighttype-Union{Tuple{MetaGraph{<:Any, <:Any, <:Any, <:Any, <:Any, <:Any, <:Any, Weight}}, Tuple{Weight}} where Weight","page":"API reference","title":"MetaGraphsNext.weighttype","text":"weighttype(meta_graph)\n\nReturn the weight type for metagraph meta_graph.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.haskey","page":"API reference","title":"Base.haskey","text":"haskey(meta_graph, label)\n\nDetermine whether a MetaGraph meta_graph contains the vertex label.\n\n\n\n\n\nhaskey(meta_graph, label_1, label_2)\n\nDetermine whether a MetaGraph meta_graph contains an edge from label_1 to label_2.\n\nThe order of label_1 and label_2 only matters if meta_graph is a digraph.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.getindex","page":"API reference","title":"Base.getindex","text":"getindex(meta_graph)\n\nReturn meta_graph metadata.\n\n\n\n\n\ngetindex(meta_graph, label)\n\nReturn vertex metadata for label.\n\n\n\n\n\ngetindex(meta_graph, label_1, label_2)\n\nReturn edge metadata for the edge between label_1 and label_2.\n\n\n\n\n\ngetindex(meta_weights::MetaWeights, code_1, code_2)\n\nGet the weight of edge (code_1, code_2).\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.setindex!","page":"API reference","title":"Base.setindex!","text":"setindex!(meta_graph, data, label)\n\nSet vertex metadata for label to data.\n\n\n\n\n\nsetindex!(meta_graph, data, label_1, label_2)\n\nSet edge metadata for (label_1, label_2) to data.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.delete!","page":"API reference","title":"Base.delete!","text":"delete!(meta_graph, label)\n\nDelete vertex label.\n\n\n\n\n\ndelete!(meta_graph, label_1, label_2)\n\nDelete edge (label_1, label_2).\n\n\n\n\n\n","category":"function"},{"location":"api/#Graphs.SimpleGraphs.add_vertex!","page":"API reference","title":"Graphs.SimpleGraphs.add_vertex!","text":"add_vertex!(meta_graph, label, data)\n\nAdd a vertex to MetaGraph meta_graph with label label having metadata data. If the VertexData type of meta_graph is Nothing, data can be omitted.\n\nReturn true if the vertex has been added, false in case the label already exists or vertex was not added.\n\n\n\n\n\n","category":"function"},{"location":"api/#Graphs.SimpleGraphs.add_edge!","page":"API reference","title":"Graphs.SimpleGraphs.add_edge!","text":"add_edge!(meta_graph, label_1, label_2, data)\n\nAdd an edge (label_1, label_2) to MetaGraph meta_graph with metadata data. If the EdgeData type of meta_graph is Nothing, data can be omitted.\n\nReturn true if the edge has been added, false otherwise. If one of the labels does not exist, nothing happens and false is returned (the label is not inserted). If (label_1, label_2) already exists, its data is updated to data and false is returned nonetheless.\n\n\n\n\n\n","category":"function"},{"location":"api/#Graphs.weights","page":"API reference","title":"Graphs.weights","text":"weights(meta_graph)\n\nReturn a matrix-like MetaWeights object containing the edge weights for metagraph meta_graph.\n\n\n\n\n\n","category":"function"},{"location":"tutorial/3_files/#File-storage","page":"File storage","title":"File storage","text":"using Graphs\nusing MetaGraphsNext","category":"section"},{"location":"tutorial/3_files/#MGFormat","page":"File storage","title":"MGFormat","text":"MetaGraphsNext.jl overloads Graphs.savegraph to write graphs in a custom format called MGFormat, which is based on JLD2. It is not very readable, but it does give the right result when we load it back. This requires JLD2 to be loaded as well.\n\nusing JLD2\n\nexample = MetaGraph(Graph(), Symbol);\n\nexample2 = mktemp() do file, io\n    savegraph(file, example)\n    loadgraph(file, \"something\", MGFormat())\nend\n\nexample2 == example","category":"section"},{"location":"tutorial/3_files/#DOTFormat","page":"File storage","title":"DOTFormat","text":"MetaGraphsNext.jl also support the more standard DOT encoding, which is used as follows.\n\nsimple = MetaGraph(Graph(), Symbol);\n\nsimple[:a] = nothing;\nsimple[:b] = nothing;\nsimple[:a, :b] = nothing;\n\nsimple_str = mktemp() do file, io\n    savegraph(file, simple, DOTFormat())\n    read(file, String)\nend\n\nsimple_str_true = \"\"\"\ngraph T {\n    \"a\"\n    \"b\"\n    \"a\" -- \"b\"\n}\n\"\"\"\n\nsimple_str == simple_str_true\n\ncomplicated = MetaGraph(\n    DiGraph();\n    label_type=Symbol,\n    vertex_data_type=Dict{Symbol,Int},\n    edge_data_type=Dict{Symbol,Int},\n    graph_data=(tagged=true,),\n);\n\ncomplicated[:a] = Dict(:code_1 => 1, :code_2 => 2);\n\ncomplicated[:b] = Dict(:code => 2);\n\ncomplicated[:a, :b] = Dict(:code => 12);\n\ncomplicated_str = mktemp() do file, io\n    savegraph(file, complicated, DOTFormat())\n    read(file, String)\nend\n\ncomplicated_str_true = \"\"\"\ndigraph G {\n    tagged = true\n    \"a\" [code_1 = 1, code_2 = 2]\n    \"b\" [code = 2]\n    \"a\" -> \"b\" [code = 12]\n}\n\"\"\"\n\nwith_spaces = MetaGraph(\n    DiGraph();\n    label_type=String,\n    vertex_data_type=Dict{Symbol,String},\n    edge_data_type=Dict{Symbol,String},\n)\n\nwith_spaces[\"a b\"] = Dict(:label => \"A B\")\n\nwith_spaces[\"c d\"] = Dict(:label => \"C D\")\n\nwith_spaces[\"a b\", \"c d\"] = Dict(:label => \"A B to C D\")\n\nwith_spaces_str = mktemp() do file, io\n    savegraph(file, with_spaces, DOTFormat())\n    read(file, String)\nend\n\nwith_spaces_str_true = \"\"\"\ndigraph G {\n    \"a b\" [label = \"A B\"]\n    \"c d\" [label = \"C D\"]\n    \"a b\" -> \"c d\" [label = \"A B to C D\"]\n}\n\"\"\"\n\nwith_spaces_str == with_spaces_str_true\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"#MetaGraphsNext.jl","page":"Home","title":"MetaGraphsNext.jl","text":"Welcome to MetaGraphsNext.jl, a type-stable replacement for MetaGraphs.jl. It allows you to create graphs with vertex and edge metadata, on which you can unleash the full power of the Graphs.jl ecosystem.","category":"section"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"To install the package, open the Julia REPL and type\n\njulia> using Pkg; Pkg.add(\"MetaGraphsNext\")","category":"section"},{"location":"tutorial/2_graphs/#Graphs.jl-interface","page":"Graphs.jl  interface","title":"Graphs.jl  interface","text":"using Graphs\nusing MetaGraphsNext\n\nMetaGraphs inherit many methods from Graphs.jl. In general, inherited methods refer to vertices by codes, not labels, for compatibility with the AbstractGraph interface.\n\nNote that vertex codes get reassigned after rem_vertex! operations to remain contiguous, so we recommend systematically converting to and from labels.","category":"section"},{"location":"tutorial/2_graphs/#Undirected-graphs","page":"Graphs.jl  interface","title":"Undirected graphs","text":"We can make MetaGraphs based on (undirected) Graphs.\n\ncities = MetaGraph(\n    Graph();\n    label_type=Symbol,\n    vertex_data_type=String,\n    edge_data_type=Int,\n    graph_data=nothing,\n    weight_function=identity,\n);\nnothing #hide\n\nLet us add some cities and the distance between them:\n\ncities[:Paris] = \"France\";\ncities[:London] = \"UK\";\ncities[:Berlin] = \"Germany\";\ncities[:Paris, :London] = 344;\ncities[:Paris, :Berlin] = 878;\nnothing #hide\n\nThe general properties of the graph are as expected:\n\nis_directed(cities)\n\neltype(cities)\n\nedgetype(cities)\n\nWe can check the set of vertices:\n\nnv(cities)\n\ncollect(vertices(cities))\n\nhas_vertex(cities, 2)\n\nhas_vertex(cities, 4)\n\nNote that we can't add the same city (i.e. vertex label) twice:\n\nadd_vertex!(cities, :London, \"Italy\")\n\nnv(cities)\n\ncities[:London]\n\nWe then check the set of edges:\n\nne(cities)\n\ncollect(edges(cities))\n\nhas_edge(cities, 1, 2)\n\nhas_edge(cities, 2, 3)\n\nFrom this initial graph, we can create some others:\n\ncopy(cities)\n\nzero(cities)\n\nSince cities is a weighted graph, we can leverage the whole Graphs.jl machinery of graph analysis and traversal:\n\ndiameter(cities)\n\nds = dijkstra_shortest_paths(cities, 2)\n\nFinally, let us remove some edges and vertices\n\nrem_edge!(cities, 1, 3);\nrem_vertex!(cities, 3);\nhas_vertex(cities, 1) && !has_vertex(cities, 3)","category":"section"},{"location":"tutorial/2_graphs/#Directed-graphs","page":"Graphs.jl  interface","title":"Directed graphs","text":"We can make MetaGraphs based on DiGraphs as well.\n\nrock_paper_scissors = MetaGraph(DiGraph(); label_type=Symbol, edge_data_type=String);\n\nfor label in [:rock, :paper, :scissors]\n    rock_paper_scissors[label] = nothing\nend\n\nrock_paper_scissors[:rock, :scissors] = \"rock beats scissors\"\nrock_paper_scissors[:scissors, :paper] = \"scissors beat paper\"\nrock_paper_scissors[:paper, :rock] = \"paper beats rock\";\nnothing #hide\n\nWe see that the underlying graph has changed:\n\nis_directed(rock_paper_scissors)\n\nDirected graphs can be reversed:\n\nhaskey(rock_paper_scissors, :scissors, :rock)\n\nhaskey(reverse(rock_paper_scissors), :scissors, :rock)\n\nLet us take a subgraph induced by a subset of vertices:\n\nrock_paper, _ = induced_subgraph(rock_paper_scissors, [1, 2])\n\nissubset(rock_paper, rock_paper_scissors)\n\nhaskey(rock_paper, :paper, :rock)\n\nhaskey(rock_paper, :rock, :scissors)\n\nSubgraphs can also be induced by a subset of edges.\n\nsubtree_edges = collect(edges(rock_paper_scissors))[2:3]\nrock_paper_scissors_subtree, _ = induced_subgraph(rock_paper_scissors, subtree_edges)\nissubset(rock_paper_scissors_subtree, rock_paper_scissors)\nne(rock_paper_scissors_subtree)\n\nnv(rock_paper_scissors_subtree)\n\n[rock_paper_scissors_subtree[e...] for e in edge_labels(rock_paper_scissors_subtree)]\n\nChecking that a graph is a subset of another is not supported yet. For example, an induced subgraph may appear as not a subset of the original graph, if vertex codes were modified.\n\nissubset(rock_paper_scissors_subtree, rock_paper_scissors)\n\nrock_scissors, _ = induced_subgraph(rock_paper_scissors, [1, 3])\nissubset(rock_scissors, rock_paper_scissors)\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"tutorial/4_type_stability/#Type-stability","page":"Type stability","title":"Type stability","text":"using Graphs\nusing MetaGraphs: MetaGraphs\nusing MetaGraphsNext","category":"section"},{"location":"tutorial/4_type_stability/#Constructor-and-access","page":"Type stability","title":"Constructor and access","text":"In the previous examples, we used a MetaGraph constructor which receives type parameters as keyword arguments. This was done for ease of exposition, but it may impede type inference, and hence reduce performance.\n\ncolors = MetaGraph(\n    Graph();  # underlying graph structure\n    label_type=Symbol,  # color name\n    vertex_data_type=NTuple{3,Int},  # RGB code\n    edge_data_type=Symbol,  # result of the addition between two colors\n    graph_data=\"additive colors\",  # tag for the whole graph\n)\n\nWhile casual users probably won't care, if your goal is performance, you might need to proceed differently.\n\nOption 1: wrap the constructor in a helper function to trigger constant propagation.\n\nfunction colors_constructor()\n    return MetaGraph(\n        Graph();\n        label_type=Symbol,\n        vertex_data_type=NTuple{3,Int},\n        edge_data_type=Symbol,\n        graph_data=\"additive colors\",\n    )\nend\n\ncolors_constructor()\n\nOption 2: switch to another constructor that uses positional arguments (be careful with the order!)\n\nMetaGraph(Graph(), Symbol, NTuple{3,Int}, Symbol, \"additive colors\")\n\nOption 3: use the constructor for a non-empty graph instead.\n\nvertices_description = [:red => (255, 0, 0), :green => (0, 255, 0), :blue => (0, 0, 255)]\nedges_description = [\n    (:red, :green) => :yellow, (:red, :blue) => :magenta, (:green, :blue) => :cyan\n]\nMetaGraph(cycle_graph(3), vertices_description, edges_description, \"additive colors\")\n\nOnce Julia can infer the full type of the MetaGraph, accessing vertex and edge metadata also becomes type-stable.","category":"section"},{"location":"tutorial/4_type_stability/#Comparison-with-MetaGraphs.jl","page":"Type stability","title":"Comparison with MetaGraphs.jl","text":"In the older package MetaGraphs.jl that we used as inspiration, data types are not specified in the graph structure. Their choice allows more flexibility and an arbitrary number of attributes which the user does not need to anticipate at construction.\n\ncolors_unstable = MetaGraphs.MetaGraph(cycle_graph(3))\n\nHere is how one would add data and labels to colors_unstable.\n\nMetaGraphs.set_indexing_prop!(colors_unstable, :label)\n\nMetaGraphs.set_prop!(colors_unstable, :graph_tag, \"additive colors\")\n\nMetaGraphs.set_props!(colors_unstable, 1, Dict(:label => :red, :rgb_code => (255, 0, 0)))\nMetaGraphs.set_props!(colors_unstable, 2, Dict(:label => :green, :rgb_code => (0, 255, 0)))\nMetaGraphs.set_props!(colors_unstable, 3, Dict(:label => :blue, :rgb_code => (0, 0, 255)))\n\nMetaGraphs.set_prop!(colors_unstable, 1, 2, :addition_result, :yellow)\nMetaGraphs.set_prop!(colors_unstable, 1, 3, :addition_result, :magenta)\nMetaGraphs.set_prop!(colors_unstable, 2, 3, :addition_result, :cyan);\nnothing #hide\n\nOne can retrieve the vertex index (which we called code) using any indexing property.\n\ncolors_unstable[:green, :label]\n\nThen we can access vertex properties...\n\nMetaGraphs.get_prop(colors_unstable, 2, :rgb_code)\n\nMetaGraphs.props(colors_unstable, 2)\n\n... and edge properties.\n\nMetaGraphs.get_prop(colors_unstable, 2, 3, :addition_result)\n\nMetaGraphs.props(colors_unstable, 2, 3)\n\nThe fact that the outputs of these calls to props are of type Dict{Symbol, Any} is at the root of the problem. It means that if we use their values in any subsequent algorithms, we introduce type instability in our code (due to Any). MetaGraphsNext.jl overcomes this obstacle thanks to a more precise storage method.\n\n\n\nThis page was generated using Literate.jl.","category":"section"}]
}
